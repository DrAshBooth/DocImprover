"""Document processing routes for the DocImprover application."""

import os
import shutil
import logging
from typing import Dict, Any, Optional, Union, Tuple, Any

from flask import (
    Blueprint, request, jsonify, session, current_app as app,
    send_file
)
from werkzeug.utils import secure_filename

from ..document_processor import DocumentProcessor
from ..utils.file_helpers import (
    get_session_id, ensure_session_dir, validate_docx_file,
    copy_files_recursively, rewrite_markdown_image_paths
)

# Configure logger
logger = logging.getLogger(__name__)

# Create a blueprint for document processing routes
documents_bp = Blueprint('documents', __name__)


@documents_bp.route('/upload', methods=['POST'])
def upload_file() -> Tuple[Any, int]:
    """Handle file upload and document improvement.
    
    This endpoint accepts a DOCX file upload, processes it using the DocumentProcessor,
    extracts and handles any embedded media files, and returns the original and improved
    Markdown content with properly rewritten image paths.
    
    Returns:
        Tuple[Any, int]: A tuple containing the JSON response and HTTP status code
    """
    if 'file' not in request.files:
        return jsonify({"error": "No file provided"}), 400
    
    file = request.files['file']
    error = validate_docx_file(file)
    if error:
        return jsonify({"error": error}), 400
    
    try:
        # Setup session and save uploaded file
        session_id = get_session_id()
        upload_dir = ensure_session_dir(session_id)
        logger.info(f"Session started: {session_id}. Upload directory: {upload_dir}")
        
        filename = secure_filename(file.filename)
        input_path = os.path.join(upload_dir, filename)
        file.save(input_path)
        
        # Process the document with OpenAI
        with DocumentProcessor() as processor:
            result = processor.improve_document(input_path)

            if "error" in result:
                return jsonify({"error": result["error"]}), 400

            # Save a reference to the improved document path before moving it
            improved_docx_path = result["improved_docx_path"]
            final_output_filename = f"improved_{filename}"
            final_output_path = os.path.join(upload_dir, final_output_filename)
            
            # First, handle media files to ensure they're in place for the document
            if result.get("media_path"):
                logger.info(f"Processing media files from: {result.get('media_path')}")
                process_media_files(result.get("media_path"), upload_dir)
                # Log contents of the session media directory for debugging
                media_dir = os.path.join(upload_dir, 'media')
                if os.path.exists(media_dir):
                    logger.info(f"Media directory contents: {os.listdir(media_dir)}")
                else:
                    logger.warning(f"Expected media directory not found: {media_dir}")
            else:
                logger.info("No media files to process")
                
            # Then save the improved document
            logger.info(f"Saving improved document from {improved_docx_path} to {final_output_path}")
            shutil.copy(improved_docx_path, final_output_path)  # Use copy instead of move to preserve original

            # Create the file reference for download
            improved_file_id = f"{session_id}/{final_output_filename}"

            # Rewrite markdown image paths for proper web display
            original_markdown_rewritten = rewrite_markdown_image_paths(
                result["original_markdown"], session_id
            )
            improved_markdown_rewritten = rewrite_markdown_image_paths(
                result["improved_markdown"], session_id
            )

            # Return the results
            return jsonify({
                "original_markdown": original_markdown_rewritten,
                "improved_markdown": improved_markdown_rewritten,
                "improved_file": improved_file_id,
                "success": True
            }), 200
        
    except Exception as e:
        logger.error(f"Error processing document: {e}", exc_info=True)
        return jsonify({"error": f"Error processing document: {str(e)}"}), 400


@documents_bp.route('/download/<session_id>/<filename>')
def download_document(session_id: str, filename: str) -> Union[Any, Tuple[str, int]]:
    """Download the specified file from the user's session directory.
    
    This endpoint allows users to download improved DOCX files that were
    generated by the application. Security measures prevent directory traversal attacks.
    
    Args:
        session_id: The unique session identifier
        filename: The name of the file to download
        
    Returns:
        Union[Any, Tuple[str, int]]: The file download response or an error with status code
    """
    try:
        # Security check: ensure filename is not attempting to traverse directories
        if '..' in filename or filename.startswith('/'):
            logger.warning(f"Rejected suspicious download path: {filename}")
            return "Not Found", 404
            
        session_dir = os.path.join(app.config['UPLOAD_FOLDER'], session_id)
        file_path = os.path.join(session_dir, filename)
        
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            logger.warning(f"Download file not found: {file_path}")
            return "File not found", 404
            
        return send_file(file_path, as_attachment=True, download_name=filename)
    except Exception as e:
        logger.error(f"Error serving download: {e}")
        return "Error processing download", 500


def process_media_files(media_path: str, upload_dir: str) -> None:
    """Process and copy media files to the session's media directory.
    
    Args:
        media_path: Path to the source media directory generated by pandoc
        upload_dir: Path to the session's upload directory
    """
    if not media_path or not os.path.exists(media_path):
        return
        
    # The destination for the 'media' directory is directly in the session's upload directory
    dest_media_dir = os.path.join(upload_dir, 'media')
    
    # If a 'media' directory already exists in the session, remove it
    if os.path.exists(dest_media_dir):
        shutil.rmtree(dest_media_dir)
    
    # Create the destination media directory
    os.makedirs(dest_media_dir, exist_ok=True)
    
    # Start recursive copy from the media path
    copy_files_recursively(media_path, dest_media_dir)
